import ShaderDestination from "../../Renderer/ShaderDestination.js";
import MetadataPickingStageFS from "../../Shaders/Model/MetadataPickingStageFS.js";
import hasMetadataProperty from "../hasMetadataProperty.js";

/**
 * A pipeline stage that updates `ModelRenderResources` for
 * picking metadata.
 *
 * It adds the `METADATA_PICKING` define that causes the parts
 * of the `ModelFS.glsl` to be skipped that are not related to
 * picking, and inserts the `METADATA_PICKING_PROPERTY_NAME`
 * define for the metadata property that should be picked.
 * The latter will directly access the property of the `Metadata`
 * struct that was generated by the `MetadataPipelineStage`.
 *
 * @namespace MetadataPickingPipelineStage
 * @private
 */
const MetadataPickingPipelineStage = {
  name: "MetadataPickingPipelineStage", // Helps with debugging if you know where to look
};

/**
 * Process a primitive.
 *
 * If the given render resources are for a model that has metadata that
 * matches the current `pickedMetadataSchemaId`, `pickedMetadataClassName`
 * and `pickedMetadataPropertyName` of the `FrameState`, then this pass...
 * <ul>
 *   <li>adds the `METADATA_PICKING` define to the fragment shader</li>
 *   <li>adds the `METADATA_PICKING_PROPERTY_NAME` to the fragment shader, using the given property name</li>
 * </ul>
 * @param {PrimitiveRenderResources} renderResources The render resources for the primitive
 * @param {ModelComponents.Primitive} primitive The primitive to be rendered
 * @param {FrameState} frameState The frame state
 * @private
 */
MetadataPickingPipelineStage.process = function (
  renderResources,
  primitive,
  frameState
) {
  const XXX_METADATA_PICKING_DEBUG_LOG = false;

  if (XXX_METADATA_PICKING_DEBUG_LOG) {
    console.log("MetadataPickingPipelineStage processing:");
    console.log("  renderResources: ", renderResources);
    console.log("  primitive: ", primitive);
    console.log("  frameState: ", frameState);
  }

  const schemaId = frameState.pickedMetadataSchemaId;
  const className = frameState.pickedMetadataClassName;
  const propertyName = frameState.pickedMetadataPropertyName;

  // Verify that the given render resources contain a model with
  // metadata that has a schema that matches the given description
  const model = renderResources.model;
  const structuralMetadata = model?.structuralMetadata;
  const schema = structuralMetadata?.schema;
  if (!hasMetadataProperty(schema, schemaId, className, propertyName)) {
    if (XXX_METADATA_PICKING_DEBUG_LOG) {
      console.log("The metadata property was not found");
    }
    return;
  }

  const shaderBuilder = renderResources.shaderBuilder;

  // Enable METADATA_PICKING in `ModelFS.glsl`
  shaderBuilder.addDefine(
    "METADATA_PICKING",
    undefined,
    ShaderDestination.FRAGMENT
  );

  // Add the MetadataPickingStageFS.glsl lines, and define
  // the property that should be picked
  shaderBuilder.addFragmentLines(MetadataPickingStageFS);
  shaderBuilder.addDefine(
    "METADATA_PICKING_PROPERTY_NAME",
    propertyName,
    ShaderDestination.FRAGMENT
  );
};

export default MetadataPickingPipelineStage;
